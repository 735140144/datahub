"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[9092],{3905:function(t,e,n){n.d(e,{Zo:function(){return p},kt:function(){return g}});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var s=a.createContext({}),d=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},p=function(t){var e=d(t.components);return a.createElement(s.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},m=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,i=t.originalType,s=t.parentName,p=o(t,["components","mdxType","originalType","parentName"]),m=d(n),g=r,c=m["".concat(s,".").concat(g)]||m[g]||u[g]||i;return n?a.createElement(c,l(l({ref:e},p),{},{components:n})):a.createElement(c,l({ref:e},p))}));function g(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o.mdxType="string"==typeof t?t:r,l[1]=o;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},98448:function(t,e,n){var a=n(67294);e.Z=function(t){var e=t.children,n=t.hidden,r=t.className;return a.createElement("div",{role:"tabpanel",hidden:n,className:r},e)}},37358:function(t,e,n){n.d(e,{Z:function(){return m}});var a=n(87462),r=n(67294),i=n(51048),l=n(22713);var o=function(){var t=(0,r.useContext)(l.Z);if(null==t)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return t},s=n(12613),d=n(86010),p="tabItem_1uMI";function u(t){var e,n,a,i=t.lazy,l=t.block,u=t.defaultValue,m=t.values,g=t.groupId,c=t.className,h=r.Children.map(t.children,(function(t){if((0,r.isValidElement)(t)&&void 0!==t.props.value)return t;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof t.type?t.type:t.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),f=null!=m?m:h.map((function(t){var e=t.props;return{value:e.value,label:e.label}})),b=(0,s.lx)(f,(function(t,e){return t.value===e.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(t){return t.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var k=null===u?u:null!=(e=null!=u?u:null==(n=h.find((function(t){return t.props.default})))?void 0:n.props.value)?e:null==(a=h[0])?void 0:a.props.value;if(null!==k&&!f.some((function(t){return t.value===k})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+k+'" but none of its children has the corresponding value. Available values are: '+f.map((function(t){return t.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var N=o(),y=N.tabGroupChoices,_=N.setTabGroupChoices,w=(0,r.useState)(k),v=w[0],T=w[1],C=[],S=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=g){var E=y[g];null!=E&&E!==v&&f.some((function(t){return t.value===E}))&&T(E)}var O=function(t){var e=t.currentTarget,n=C.indexOf(e),a=f[n].value;a!==v&&(S(e),T(a),null!=g&&_(g,a))},D=function(t){var e,n=null;switch(t.key){case"ArrowRight":var a=C.indexOf(t.currentTarget)+1;n=C[a]||C[0];break;case"ArrowLeft":var r=C.indexOf(t.currentTarget)-1;n=C[r]||C[C.length-1]}null==(e=n)||e.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,d.Z)("tabs",{"tabs--block":l},c)},f.map((function(t){var e=t.value,n=t.label;return r.createElement("li",{role:"tab",tabIndex:v===e?0:-1,"aria-selected":v===e,className:(0,d.Z)("tabs__item",p,{"tabs__item--active":v===e}),key:e,ref:function(t){return C.push(t)},onKeyDown:D,onFocus:O,onClick:O},null!=n?n:e)}))),i?(0,r.cloneElement)(h.filter((function(t){return t.props.value===v}))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},h.map((function(t,e){return(0,r.cloneElement)(t,{key:e,hidden:t.props.value!==v})}))))}function m(t){var e=(0,i.Z)();return r.createElement(u,(0,a.Z)({key:String(e)},t))}},22713:function(t,e,n){var a=(0,n(67294).createContext)(void 0);e.Z=a},41649:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return d},contentTitle:function(){return p},metadata:function(){return u},toc:function(){return m},default:function(){return c}});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),l=n(37358),o=n(98448),s=["components"],d={title:"dbt",slug:"/generated/ingestion/sources/dbt",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/ingestion/sources/dbt.md"},p="dbt",u={unversionedId:"docs/generated/ingestion/sources/dbt",id:"docs/generated/ingestion/sources/dbt",isDocsHomePage:!1,title:"dbt",description:"Module dbt",source:"@site/genDocs/docs/generated/ingestion/sources/dbt.md",sourceDirName:"docs/generated/ingestion/sources",slug:"/generated/ingestion/sources/dbt",permalink:"/docs/generated/ingestion/sources/dbt",editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/generated/ingestion/sources/dbt.md",tags:[],version:"current",frontMatter:{title:"dbt",slug:"/generated/ingestion/sources/dbt",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/ingestion/sources/dbt.md"},sidebar:"overviewSidebar",previous:{title:"CSV",permalink:"/docs/generated/ingestion/sources/csv"},next:{title:"Delta Lake",permalink:"/docs/generated/ingestion/sources/delta-lake"}},m=[{value:"Module <code>dbt</code>",id:"module-dbt",children:[{value:"Important Capabilities",id:"important-capabilities",children:[],level:3},{value:"Install the Plugin",id:"install-the-plugin",children:[],level:3},{value:"Quickstart Recipe",id:"quickstart-recipe",children:[],level:3},{value:"Config Details",id:"config-details",children:[],level:3},{value:"dbt meta automated mappings",id:"dbt-meta-automated-mappings",children:[{value:"Data Tier - Bronze, Silver, Gold",id:"data-tier---bronze-silver-gold",children:[],level:4},{value:"Case Numbers - create tags",id:"case-numbers---create-tags",children:[],level:4},{value:"Stripping out leading @ sign",id:"stripping-out-leading--sign",children:[],level:4}],level:3},{value:"dbt query_tag automated mappings",id:"dbt-query_tag-automated-mappings",children:[],level:3},{value:"Integrating with dbt test",id:"integrating-with-dbt-test",children:[{value:"View of dbt tests for a dataset",id:"view-of-dbt-tests-for-a-dataset",children:[],level:4},{value:"Viewing the SQL for a dbt test",id:"viewing-the-sql-for-a-dbt-test",children:[],level:4},{value:"Viewing timeline for a failed dbt test",id:"viewing-timeline-for-a-failed-dbt-test",children:[],level:4},{value:"Separating test result emission from other metadata emission",id:"separating-test-result-emission-from-other-metadata-emission",children:[],level:4}],level:3},{value:"Code Coordinates",id:"code-coordinates",children:[],level:3}],level:2},{value:"Questions",id:"questions",children:[],level:2}],g={toc:m};function c(t){var e=t.components,n=(0,r.Z)(t,s);return(0,i.kt)("wrapper",(0,a.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"dbt"},"dbt"),(0,i.kt)("h2",{id:"module-dbt"},"Module ",(0,i.kt)("inlineCode",{parentName:"h2"},"dbt")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://img.shields.io/badge/support%20status-certified-brightgreen",alt:"Certified"})),(0,i.kt)("h3",{id:"important-capabilities"},"Important Capabilities"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Capability"),(0,i.kt)("th",{parentName:"tr",align:null},"Status"),(0,i.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Dataset Usage"),(0,i.kt)("td",{parentName:"tr",align:null},"\u274c"),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/docs/metadata-ingestion/docs/dev_guides/stateful#removal-of-stale-tables-and-views"},"Detect Deleted Entities")),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"Enabled via stateful ingestion")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Table-Level Lineage"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"Enabled by default")))),(0,i.kt)("p",null,"This plugin pulls metadata from dbt's artifact files and generates:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"dbt Tables: for nodes in the dbt manifest file that are models materialized as tables"),(0,i.kt)("li",{parentName:"ul"},"dbt Views: for nodes in the dbt manifest file that are models materialized as views"),(0,i.kt)("li",{parentName:"ul"},"dbt Ephemeral: for nodes in the dbt manifest file that are ephemeral models"),(0,i.kt)("li",{parentName:"ul"},"dbt Sources: for nodes that are sources on top of the underlying platform tables"),(0,i.kt)("li",{parentName:"ul"},"dbt Seed: for seed entities"),(0,i.kt)("li",{parentName:"ul"},"dbt Tests as Assertions: for dbt test entities (starting with version 0.8.38.1)")),(0,i.kt)("p",null,"Note:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"It also generates lineage between the ",(0,i.kt)("inlineCode",{parentName:"li"},"dbt")," nodes (e.g. ephemeral nodes that depend on other dbt sources) as well as lineage between the ",(0,i.kt)("inlineCode",{parentName:"li"},"dbt")," nodes and the underlying (target) platform nodes (e.g. BigQuery Table -> dbt Source, dbt View -> BigQuery View)."),(0,i.kt)("li",{parentName:"ol"},"The previous version of this source (",(0,i.kt)("inlineCode",{parentName:"li"},"acryl_datahub<=0.8.16.2"),") did not generate ",(0,i.kt)("inlineCode",{parentName:"li"},"dbt")," entities and lineage between ",(0,i.kt)("inlineCode",{parentName:"li"},"dbt")," entities and platform entities. For backwards compatibility with the previous version of this source, there is a config flag ",(0,i.kt)("inlineCode",{parentName:"li"},"disable_dbt_node_creation")," that falls back to the old behavior."),(0,i.kt)("li",{parentName:"ol"},"We also support automated actions (like add a tag, term or owner) based on properties defined in dbt meta.")),(0,i.kt)("p",null,"The artifacts used by this source are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.getdbt.com/reference/artifacts/manifest-json"},"dbt manifest file"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This file contains model, source, tests and lineage data."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.getdbt.com/reference/artifacts/catalog-json"},"dbt catalog file"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This file contains schema data."),(0,i.kt)("li",{parentName:"ul"},"dbt does not record schema data for Ephemeral models, as such datahub will show Ephemeral models in the lineage, however there will be no associated schema for Ephemeral models"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.getdbt.com/reference/artifacts/sources-json"},"dbt sources file"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This file contains metadata for sources with freshness checks."),(0,i.kt)("li",{parentName:"ul"},"We transfer dbt's freshness checks to DataHub's last-modified fields."),(0,i.kt)("li",{parentName:"ul"},"Note that this file is optional \u2013 if not specified, we'll use time of ingestion instead as a proxy for time last-modified."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.getdbt.com/reference/artifacts/run-results-json"},"dbt run_results file"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This file contains metadata from the result of a dbt run, e.g. dbt test"),(0,i.kt)("li",{parentName:"ul"},"When provided, we transfer dbt test run results into assertion run events to see a timeline of test runs on the dataset")))),(0,i.kt)("h3",{id:"install-the-plugin"},"Install the Plugin"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"pip install 'acryl-datahub[dbt]'\n")),(0,i.kt)("h3",{id:"quickstart-recipe"},"Quickstart Recipe"),(0,i.kt)("p",null,"Check out the following recipe to get started with ingestion! See ",(0,i.kt)("a",{parentName:"p",href:"#config-details"},"below")," for full configuration options."),(0,i.kt)("p",null,"For general pointers on writing and running a recipe, see our ",(0,i.kt)("a",{parentName:"p",href:"/docs/metadata-ingestion#recipes"},"main recipe guide")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'source:\n  type: "dbt"\n  config:\n    # Coordinates\n    # To use this as-is, set the environment variable DBT_PROJECT_ROOT to the root folder of your dbt project\n    manifest_path: "${DBT_PROJECT_ROOT}/target/manifest_file.json"\n    catalog_path: "${DBT_PROJECT_ROOT}/target/catalog_file.json"\n    sources_path: "${DBT_PROJECT_ROOT}/target/sources_file.json"  # optional for freshness\n    test_results_path: "${DBT_PROJECT_ROOT}/target/run_results.json" # optional for recording dbt test results after running dbt test\n\n    # Options\n    target_platform: "my_target_platform_id" # e.g. bigquery/postgres/etc.\n    load_schemas: False # note: enable this only if you are not ingesting metadata from your warehouse\n\n# sink configs\n\n')),(0,i.kt)("h3",{id:"config-details"},"Config Details"),(0,i.kt)(l.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"options",label:"Options",default:!0,mdxType:"TabItem"},(0,i.kt)("p",null,"Note that a ",(0,i.kt)("inlineCode",{parentName:"p"},".")," is used to denote nested fields in the YAML recipe."),(0,i.kt)("details",{open:!0},(0,i.kt)("summary",null,"View All Configuration Options"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Field"),(0,i.kt)("th",{parentName:"tr",align:null},"Required"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"),(0,i.kt)("th",{parentName:"tr",align:null},"Default"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"env"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Environment to use in namespace when constructing URNs."),(0,i.kt)("td",{parentName:"tr",align:null},"PROD")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"platform"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"The platform that this source connects to"),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"platform_instance"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"The instance of the platform that all assets produced by this recipe belong to"),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"manifest_path"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Path to dbt manifest JSON. See ",(0,i.kt)("a",{parentName:"td",href:"https://docs.getdbt.com/reference/artifacts/manifest-json"},"https://docs.getdbt.com/reference/artifacts/manifest-json")," Note this can be a local file or a URI."),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"catalog_path"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Path to dbt catalog JSON. See ",(0,i.kt)("a",{parentName:"td",href:"https://docs.getdbt.com/reference/artifacts/catalog-json"},"https://docs.getdbt.com/reference/artifacts/catalog-json")," Note this can be a local file or a URI."),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sources_path"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Path to dbt sources JSON. See ",(0,i.kt)("a",{parentName:"td",href:"https://docs.getdbt.com/reference/artifacts/sources-json"},"https://docs.getdbt.com/reference/artifacts/sources-json"),". If not specified, last-modified fields will not be populated. Note this can be a local file or a URI."),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"test_results_path"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Path to output of dbt test run as run_results file in JSON format. See ",(0,i.kt)("a",{parentName:"td",href:"https://docs.getdbt.com/reference/artifacts/run-results-json"},"https://docs.getdbt.com/reference/artifacts/run-results-json"),". If not specified, test execution results will not be populated in DataHub."),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"target_platform"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"The platform that dbt is loading onto. (e.g. bigquery / redshift / postgres etc.)"),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"target_platform_instance"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"The platform instance for the platform that dbt is operating on. Use this if you have multiple instances of the same platform (e.g. redshift) and need to distinguish between them."),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"load_schemas"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"This flag is only consulted when disable_dbt_node_creation is set to True. Load schemas for target_platform entities from dbt catalog file, not necessary when you are already ingesting this metadata from the data platform directly. If set to False, table schema details (e.g. columns) will not be ingested."),(0,i.kt)("td",{parentName:"tr",align:null},"True")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"use_identifiers"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"Use model identifier instead of model name if defined (if not, default to model name)."),(0,i.kt)("td",{parentName:"tr",align:null},"False")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"tag_prefix"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Prefix added to tags during ingestion."),(0,i.kt)("td",{parentName:"tr",align:null},"dbt:")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"meta_mapping"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Dict"),(0,i.kt)("td",{parentName:"tr",align:null},"mapping rules that will be executed against dbt meta properties. Refer to the section below on dbt meta automated mappings."),(0,i.kt)("td",{parentName:"tr",align:null},"{}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"query_tag_mapping"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Dict"),(0,i.kt)("td",{parentName:"tr",align:null},"mapping rules that will be executed against dbt query_tag meta properties. Refer to the section below on dbt meta automated mappings."),(0,i.kt)("td",{parentName:"tr",align:null},"{}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"write_semantics"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},'Whether the new tags, terms and owners to be added will override the existing ones added only by this source or not. Value for this config can be "PATCH" or "OVERRIDE"'),(0,i.kt)("td",{parentName:"tr",align:null},"PATCH")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"strip_user_ids_from_email"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"Whether or not to strip email id while adding owners using dbt meta actions."),(0,i.kt)("td",{parentName:"tr",align:null},"False")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"enable_owner_extraction"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"When enabled, ownership info will be extracted from the dbt meta"),(0,i.kt)("td",{parentName:"tr",align:null},"True")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"owner_extraction_pattern"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Regex string to extract owner from the dbt node using the ",(0,i.kt)("inlineCode",{parentName:"td"},"(?P<name>...) syntax")," of the ",(0,i.kt)("a",{parentName:"td",href:"https://docs.python.org/3/library/re.html#match-objects"},"match object"),", where the group name must be ",(0,i.kt)("inlineCode",{parentName:"td"},"owner"),". Examples: (1)",(0,i.kt)("inlineCode",{parentName:"td"},'r"(?P<owner>(.*)): (\\w+) (\\w+)"')," will extract ",(0,i.kt)("inlineCode",{parentName:"td"},"jdoe")," as the owner from ",(0,i.kt)("inlineCode",{parentName:"td"},'"jdoe: John Doe"')," (2) ",(0,i.kt)("inlineCode",{parentName:"td"},'r"@(?P<owner>(.*))"')," will extract ",(0,i.kt)("inlineCode",{parentName:"td"},"alice")," as the owner from ",(0,i.kt)("inlineCode",{parentName:"td"},'"@alice"'),"."),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"delete_tests_as_datasets"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"Prior to version 0.8.38, dbt tests were represented as datasets. If you ingested dbt tests before, set this flag to True (just needed once) to soft-delete tests that were generated as datasets by previous ingestion."),(0,i.kt)("td",{parentName:"tr",align:null},"False")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"backcompat_skip_source_on_lineage_edge"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"Prior to version 0.8.41, lineage edges to sources were directed to the target platform node rather than the dbt source node. This contradicted the established pattern for other lineage edges to point to upstream dbt nodes. To revert lineage logic to this legacy approach, set this flag to true."),(0,i.kt)("td",{parentName:"tr",align:null},"False")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"disable_dbt_node_creation"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"Whether to suppress dbt dataset metadata creation. When set to True, this flag applies the dbt metadata to the target_platform entities (e.g. populating schema and column descriptions from dbt into the postgres / bigquery table metadata in DataHub) and generates lineage between the platform entities."),(0,i.kt)("td",{parentName:"tr",align:null},"False")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"enable_meta_mapping"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"When enabled, applies the mappings that are defined through the meta_mapping directives."),(0,i.kt)("td",{parentName:"tr",align:null},"True")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"enable_query_tag_mapping"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"When enabled, applies the mappings that are defined through the ",(0,i.kt)("inlineCode",{parentName:"td"},"query_tag_mapping")," directives."),(0,i.kt)("td",{parentName:"tr",align:null},"True")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"stateful_ingestion"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"DBTStatefulIngestionConfig (see below for fields)"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"stateful_ingestion.enabled"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"The type of the ingestion state provider registered with datahub."),(0,i.kt)("td",{parentName:"tr",align:null},"False")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"stateful_ingestion.max_checkpoint_state_size"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"integer"),(0,i.kt)("td",{parentName:"tr",align:null},"The maximum size of the checkpoint state in bytes. Default is 16MB"),(0,i.kt)("td",{parentName:"tr",align:null},"16777216")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"stateful_ingestion.state_provider"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"DynamicTypedStateProviderConfig (see below for fields)"),(0,i.kt)("td",{parentName:"tr",align:null},"The ingestion state provider configuration."),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"stateful_ingestion.state_provider.type"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"The type of the state provider to use. For DataHub use ",(0,i.kt)("inlineCode",{parentName:"td"},"datahub")),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"stateful_ingestion.state_provider.config"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Generic dict"),(0,i.kt)("td",{parentName:"tr",align:null},"The configuration required for initializing the state provider. Default: The datahub_api config if set at pipeline level. Otherwise, the default DatahubClientConfig. See the defaults (",(0,i.kt)("a",{parentName:"td",href:"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/src/datahub/ingestion/graph/client.py#L19"},"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/src/datahub/ingestion/graph/client.py#L19"),")."),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"stateful_ingestion.ignore_old_state"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"If set to True, ignores the previous checkpoint state."),(0,i.kt)("td",{parentName:"tr",align:null},"False")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"stateful_ingestion.ignore_new_state"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"If set to True, ignores the current checkpoint state."),(0,i.kt)("td",{parentName:"tr",align:null},"False")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"stateful_ingestion.remove_stale_metadata"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"True")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"node_type_pattern"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"AllowDenyPattern (see below for fields)"),(0,i.kt)("td",{parentName:"tr",align:null},"Deprecated: use entities_enabled instead. Regex patterns for dbt nodes to filter in ingestion."),(0,i.kt)("td",{parentName:"tr",align:null},"{'allow': ","['.*']",", 'deny': [], 'ignoreCase': True}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"node_type_pattern.allow"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Array of string"),(0,i.kt)("td",{parentName:"tr",align:null},"List of regex patterns to include in ingestion"),(0,i.kt)("td",{parentName:"tr",align:null},"['.*']")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"node_type_pattern.deny"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Array of string"),(0,i.kt)("td",{parentName:"tr",align:null},"List of regex patterns to exclude from ingestion."),(0,i.kt)("td",{parentName:"tr",align:null},"[]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"node_type_pattern.ignoreCase"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"Whether to ignore case sensitivity during pattern matching."),(0,i.kt)("td",{parentName:"tr",align:null},"True")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"entities_enabled"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"DBTEntitiesEnabled (see below for fields)"),(0,i.kt)("td",{parentName:"tr",align:null},"Controls for enabling / disabling metadata emission for different dbt entities (models, test definitions, test results, etc.)"),(0,i.kt)("td",{parentName:"tr",align:null},"{'models': <EmitDirective.YES: 'YES'>, 'sources': <EmitDirective.YES: 'YES'>, 'seeds': <EmitDirective.YES: 'YES'>, 'test_definitions': <EmitDirective.YES: 'YES'>, 'test_results': <EmitDirective.YES: 'YES'>}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"entities_enabled.models"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"enum(EmitDirective)"),(0,i.kt)("td",{parentName:"tr",align:null},"Emit metadata for dbt models when set to Yes or Only. Allowed symbols are YES, NO, ONLY"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"entities_enabled.sources"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"enum(EmitDirective)"),(0,i.kt)("td",{parentName:"tr",align:null},"Emit metadata for dbt sources when set to Yes or Only. Allowed symbols are YES, NO, ONLY"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"entities_enabled.seeds"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"enum(EmitDirective)"),(0,i.kt)("td",{parentName:"tr",align:null},"Emit metadata for dbt seeds when set to Yes or Only. Allowed symbols are YES, NO, ONLY"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"entities_enabled.test_definitions"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"enum(EmitDirective)"),(0,i.kt)("td",{parentName:"tr",align:null},"Emit metadata for test definitions when enabled when set to Yes or Only. Allowed symbols are YES, NO, ONLY"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"entities_enabled.test_results"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"enum(EmitDirective)"),(0,i.kt)("td",{parentName:"tr",align:null},"Emit metadata for test results when set to Yes or Only. Allowed symbols are YES, NO, ONLY"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"node_name_pattern"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"AllowDenyPattern (see below for fields)"),(0,i.kt)("td",{parentName:"tr",align:null},"regex patterns for dbt model names to filter in ingestion."),(0,i.kt)("td",{parentName:"tr",align:null},"{'allow': ","['.*']",", 'deny': [], 'ignoreCase': True}")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"node_name_pattern.allow"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Array of string"),(0,i.kt)("td",{parentName:"tr",align:null},"List of regex patterns to include in ingestion"),(0,i.kt)("td",{parentName:"tr",align:null},"['.*']")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"node_name_pattern.deny"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Array of string"),(0,i.kt)("td",{parentName:"tr",align:null},"List of regex patterns to exclude from ingestion."),(0,i.kt)("td",{parentName:"tr",align:null},"[]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"node_name_pattern.ignoreCase"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"Whether to ignore case sensitivity during pattern matching."),(0,i.kt)("td",{parentName:"tr",align:null},"True")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"aws_connection"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"AwsConnectionConfig (see below for fields)"),(0,i.kt)("td",{parentName:"tr",align:null},"When fetching manifest files from s3, configuration for aws connection details"),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"aws_connection.aws_access_key_id"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Autodetected. See ",(0,i.kt)("a",{parentName:"td",href:"https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html"},"https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html")),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"aws_connection.aws_secret_access_key"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Autodetected. See ",(0,i.kt)("a",{parentName:"td",href:"https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html"},"https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html")),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"aws_connection.aws_session_token"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Autodetected. See ",(0,i.kt)("a",{parentName:"td",href:"https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html"},"https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html")),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"aws_connection.aws_role"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Generic dict"),(0,i.kt)("td",{parentName:"tr",align:null},"Autodetected. See ",(0,i.kt)("a",{parentName:"td",href:"https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html"},"https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html")),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"aws_connection.aws_profile"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Named AWS profile to use, if not set the default will be used"),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"aws_connection.aws_region"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"AWS region code."),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"aws_connection.aws_endpoint_url"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Autodetected. See ",(0,i.kt)("a",{parentName:"td",href:"https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html"},"https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html")),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"aws_connection.aws_proxy"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"Dict","[str,string]"),(0,i.kt)("td",{parentName:"tr",align:null},"Autodetected. See ",(0,i.kt)("a",{parentName:"td",href:"https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html"},"https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html")),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"github_info"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"GitHubInfo (see below for fields)"),(0,i.kt)("td",{parentName:"tr",align:null},"Reference to your github location to enable easy navigation from DataHub to your dbt files."),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"github_info.repo"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Name of your github repo. e.g. repo for ",(0,i.kt)("a",{parentName:"td",href:"https://github.com/datahub-project/datahub"},"https://github.com/datahub-project/datahub")," is ",(0,i.kt)("inlineCode",{parentName:"td"},"datahub-project/datahub"),"."),(0,i.kt)("td",{parentName:"tr",align:null},"None")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"github_info.branch"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Branch on which your files live by default. Typically main or master."),(0,i.kt)("td",{parentName:"tr",align:null},"main")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"github_info.base_url"),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Base url for Github"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"https://github.com"},"https://github.com"))))))),(0,i.kt)(o.Z,{value:"schema",label:"Schema",mdxType:"TabItem"},(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://json-schema.org/"},"JSONSchema")," for this configuration is inlined below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "title": "DBTConfig",\n  "description": "Base configuration class for stateful ingestion for source configs to inherit from.",\n  "type": "object",\n  "properties": {\n    "env": {\n      "title": "Env",\n      "description": "Environment to use in namespace when constructing URNs.",\n      "default": "PROD",\n      "type": "string"\n    },\n    "platform": {\n      "title": "Platform",\n      "description": "The platform that this source connects to",\n      "type": "string"\n    },\n    "platform_instance": {\n      "title": "Platform Instance",\n      "description": "The instance of the platform that all assets produced by this recipe belong to",\n      "type": "string"\n    },\n    "stateful_ingestion": {\n      "$ref": "#/definitions/DBTStatefulIngestionConfig"\n    },\n    "manifest_path": {\n      "title": "Manifest Path",\n      "description": "Path to dbt manifest JSON. See https://docs.getdbt.com/reference/artifacts/manifest-json Note this can be a local file or a URI.",\n      "type": "string"\n    },\n    "catalog_path": {\n      "title": "Catalog Path",\n      "description": "Path to dbt catalog JSON. See https://docs.getdbt.com/reference/artifacts/catalog-json Note this can be a local file or a URI.",\n      "type": "string"\n    },\n    "sources_path": {\n      "title": "Sources Path",\n      "description": "Path to dbt sources JSON. See https://docs.getdbt.com/reference/artifacts/sources-json. If not specified, last-modified fields will not be populated. Note this can be a local file or a URI.",\n      "type": "string"\n    },\n    "test_results_path": {\n      "title": "Test Results Path",\n      "description": "Path to output of dbt test run as run_results file in JSON format. See https://docs.getdbt.com/reference/artifacts/run-results-json. If not specified, test execution results will not be populated in DataHub.",\n      "type": "string"\n    },\n    "target_platform": {\n      "title": "Target Platform",\n      "description": "The platform that dbt is loading onto. (e.g. bigquery / redshift / postgres etc.)",\n      "type": "string"\n    },\n    "target_platform_instance": {\n      "title": "Target Platform Instance",\n      "description": "The platform instance for the platform that dbt is operating on. Use this if you have multiple instances of the same platform (e.g. redshift) and need to distinguish between them.",\n      "type": "string"\n    },\n    "load_schemas": {\n      "title": "Load Schemas",\n      "description": "This flag is only consulted when disable_dbt_node_creation is set to True. Load schemas for target_platform entities from dbt catalog file, not necessary when you are already ingesting this metadata from the data platform directly. If set to False, table schema details (e.g. columns) will not be ingested.",\n      "default": true,\n      "type": "boolean"\n    },\n    "use_identifiers": {\n      "title": "Use Identifiers",\n      "description": "Use model identifier instead of model name if defined (if not, default to model name).",\n      "default": false,\n      "type": "boolean"\n    },\n    "node_type_pattern": {\n      "title": "Node Type Pattern",\n      "description": "Deprecated: use entities_enabled instead. Regex patterns for dbt nodes to filter in ingestion.",\n      "default": {\n        "allow": [\n          ".*"\n        ],\n        "deny": [],\n        "ignoreCase": true\n      },\n      "allOf": [\n        {\n          "$ref": "#/definitions/AllowDenyPattern"\n        }\n      ]\n    },\n    "entities_enabled": {\n      "title": "Entities Enabled",\n      "description": "Controls for enabling / disabling metadata emission for different dbt entities (models, test definitions, test results, etc.)",\n      "default": {\n        "models": "YES",\n        "sources": "YES",\n        "seeds": "YES",\n        "test_definitions": "YES",\n        "test_results": "YES"\n      },\n      "allOf": [\n        {\n          "$ref": "#/definitions/DBTEntitiesEnabled"\n        }\n      ]\n    },\n    "tag_prefix": {\n      "title": "Tag Prefix",\n      "description": "Prefix added to tags during ingestion.",\n      "default": "dbt:",\n      "type": "string"\n    },\n    "node_name_pattern": {\n      "title": "Node Name Pattern",\n      "description": "regex patterns for dbt model names to filter in ingestion.",\n      "default": {\n        "allow": [\n          ".*"\n        ],\n        "deny": [],\n        "ignoreCase": true\n      },\n      "allOf": [\n        {\n          "$ref": "#/definitions/AllowDenyPattern"\n        }\n      ]\n    },\n    "meta_mapping": {\n      "title": "Meta Mapping",\n      "description": "mapping rules that will be executed against dbt meta properties. Refer to the section below on dbt meta automated mappings.",\n      "default": {},\n      "type": "object"\n    },\n    "query_tag_mapping": {\n      "title": "Query Tag Mapping",\n      "description": "mapping rules that will be executed against dbt query_tag meta properties. Refer to the section below on dbt meta automated mappings.",\n      "default": {},\n      "type": "object"\n    },\n    "write_semantics": {\n      "title": "Write Semantics",\n      "description": "Whether the new tags, terms and owners to be added will override the existing ones added only by this source or not. Value for this config can be \\"PATCH\\" or \\"OVERRIDE\\"",\n      "default": "PATCH",\n      "type": "string"\n    },\n    "strip_user_ids_from_email": {\n      "title": "Strip User Ids From Email",\n      "description": "Whether or not to strip email id while adding owners using dbt meta actions.",\n      "default": false,\n      "type": "boolean"\n    },\n    "enable_owner_extraction": {\n      "title": "Enable Owner Extraction",\n      "description": "When enabled, ownership info will be extracted from the dbt meta",\n      "default": true,\n      "type": "boolean"\n    },\n    "owner_extraction_pattern": {\n      "title": "Owner Extraction Pattern",\n      "description": "Regex string to extract owner from the dbt node using the `(?P<name>...) syntax` of the [match object](https://docs.python.org/3/library/re.html#match-objects), where the group name must be `owner`. Examples: (1)`r\\"(?P<owner>(.*)): (\\\\w+) (\\\\w+)\\"` will extract `jdoe` as the owner from `\\"jdoe: John Doe\\"` (2) `r\\"@(?P<owner>(.*))\\"` will extract `alice` as the owner from `\\"@alice\\"`.",\n      "type": "string"\n    },\n    "aws_connection": {\n      "title": "Aws Connection",\n      "description": "When fetching manifest files from s3, configuration for aws connection details",\n      "allOf": [\n        {\n          "$ref": "#/definitions/AwsConnectionConfig"\n        }\n      ]\n    },\n    "delete_tests_as_datasets": {\n      "title": "Delete Tests As Datasets",\n      "description": "Prior to version 0.8.38, dbt tests were represented as datasets. If you ingested dbt tests before, set this flag to True (just needed once) to soft-delete tests that were generated as datasets by previous ingestion.",\n      "default": false,\n      "type": "boolean"\n    },\n    "backcompat_skip_source_on_lineage_edge": {\n      "title": "Backcompat Skip Source On Lineage Edge",\n      "description": "Prior to version 0.8.41, lineage edges to sources were directed to the target platform node rather than the dbt source node. This contradicted the established pattern for other lineage edges to point to upstream dbt nodes. To revert lineage logic to this legacy approach, set this flag to true.",\n      "default": false,\n      "type": "boolean"\n    },\n    "github_info": {\n      "title": "Github Info",\n      "description": "Reference to your github location to enable easy navigation from DataHub to your dbt files.",\n      "allOf": [\n        {\n          "$ref": "#/definitions/GitHubInfo"\n        }\n      ]\n    },\n    "disable_dbt_node_creation": {\n      "title": "Disable Dbt Node Creation",\n      "description": "Whether to suppress dbt dataset metadata creation. When set to True, this flag applies the dbt metadata to the target_platform entities (e.g. populating schema and column descriptions from dbt into the postgres / bigquery table metadata in DataHub) and generates lineage between the platform entities.",\n      "default": false,\n      "type": "boolean"\n    },\n    "enable_meta_mapping": {\n      "title": "Enable Meta Mapping",\n      "description": "When enabled, applies the mappings that are defined through the meta_mapping directives.",\n      "default": true,\n      "type": "boolean"\n    },\n    "enable_query_tag_mapping": {\n      "title": "Enable Query Tag Mapping",\n      "description": "When enabled, applies the mappings that are defined through the `query_tag_mapping` directives.",\n      "default": true,\n      "type": "boolean"\n    }\n  },\n  "required": [\n    "manifest_path",\n    "catalog_path",\n    "target_platform"\n  ],\n  "additionalProperties": false,\n  "definitions": {\n    "DynamicTypedStateProviderConfig": {\n      "title": "DynamicTypedStateProviderConfig",\n      "type": "object",\n      "properties": {\n        "type": {\n          "title": "Type",\n          "description": "The type of the state provider to use. For DataHub use `datahub`",\n          "type": "string"\n        },\n        "config": {\n          "title": "Config",\n          "description": "The configuration required for initializing the state provider. Default: The datahub_api config if set at pipeline level. Otherwise, the default DatahubClientConfig. See the defaults (https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/src/datahub/ingestion/graph/client.py#L19)."\n        }\n      },\n      "required": [\n        "type"\n      ],\n      "additionalProperties": false\n    },\n    "DBTStatefulIngestionConfig": {\n      "title": "DBTStatefulIngestionConfig",\n      "description": "Specialization of basic StatefulIngestionConfig to adding custom config.\\nThis will be used to override the stateful_ingestion config param of StatefulIngestionConfigBase\\nin the SQLAlchemyConfig.",\n      "type": "object",\n      "properties": {\n        "enabled": {\n          "title": "Enabled",\n          "description": "The type of the ingestion state provider registered with datahub.",\n          "default": false,\n          "type": "boolean"\n        },\n        "max_checkpoint_state_size": {\n          "title": "Max Checkpoint State Size",\n          "description": "The maximum size of the checkpoint state in bytes. Default is 16MB",\n          "default": 16777216,\n          "exclusiveMinimum": 0,\n          "type": "integer"\n        },\n        "state_provider": {\n          "title": "State Provider",\n          "description": "The ingestion state provider configuration.",\n          "allOf": [\n            {\n              "$ref": "#/definitions/DynamicTypedStateProviderConfig"\n            }\n          ]\n        },\n        "ignore_old_state": {\n          "title": "Ignore Old State",\n          "description": "If set to True, ignores the previous checkpoint state.",\n          "default": false,\n          "type": "boolean"\n        },\n        "ignore_new_state": {\n          "title": "Ignore New State",\n          "description": "If set to True, ignores the current checkpoint state.",\n          "default": false,\n          "type": "boolean"\n        },\n        "remove_stale_metadata": {\n          "title": "Remove Stale Metadata",\n          "default": true,\n          "type": "boolean"\n        }\n      },\n      "additionalProperties": false\n    },\n    "AllowDenyPattern": {\n      "title": "AllowDenyPattern",\n      "description": "A class to store allow deny regexes",\n      "type": "object",\n      "properties": {\n        "allow": {\n          "title": "Allow",\n          "description": "List of regex patterns to include in ingestion",\n          "default": [\n            ".*"\n          ],\n          "type": "array",\n          "items": {\n            "type": "string"\n          }\n        },\n        "deny": {\n          "title": "Deny",\n          "description": "List of regex patterns to exclude from ingestion.",\n          "default": [],\n          "type": "array",\n          "items": {\n            "type": "string"\n          }\n        },\n        "ignoreCase": {\n          "title": "Ignorecase",\n          "description": "Whether to ignore case sensitivity during pattern matching.",\n          "default": true,\n          "type": "boolean"\n        }\n      },\n      "additionalProperties": false\n    },\n    "EmitDirective": {\n      "title": "EmitDirective",\n      "description": "A holder for directives for emission for specific types of entities",\n      "enum": [\n        "YES",\n        "NO",\n        "ONLY"\n      ]\n    },\n    "DBTEntitiesEnabled": {\n      "title": "DBTEntitiesEnabled",\n      "description": "Controls which dbt entities are going to be emitted by this source",\n      "type": "object",\n      "properties": {\n        "models": {\n          "description": "Emit metadata for dbt models when set to Yes or Only",\n          "default": "Yes",\n          "allOf": [\n            {\n              "$ref": "#/definitions/EmitDirective"\n            }\n          ]\n        },\n        "sources": {\n          "description": "Emit metadata for dbt sources when set to Yes or Only",\n          "default": "Yes",\n          "allOf": [\n            {\n              "$ref": "#/definitions/EmitDirective"\n            }\n          ]\n        },\n        "seeds": {\n          "description": "Emit metadata for dbt seeds when set to Yes or Only",\n          "default": "Yes",\n          "allOf": [\n            {\n              "$ref": "#/definitions/EmitDirective"\n            }\n          ]\n        },\n        "test_definitions": {\n          "description": "Emit metadata for test definitions when enabled when set to Yes or Only",\n          "default": "Yes",\n          "allOf": [\n            {\n              "$ref": "#/definitions/EmitDirective"\n            }\n          ]\n        },\n        "test_results": {\n          "description": "Emit metadata for test results when set to Yes or Only",\n          "default": "Yes",\n          "allOf": [\n            {\n              "$ref": "#/definitions/EmitDirective"\n            }\n          ]\n        }\n      }\n    },\n    "AwsConnectionConfig": {\n      "title": "AwsConnectionConfig",\n      "description": "Common AWS credentials config.\\n\\nCurrently used by:\\n    - Glue source\\n    - SageMaker source\\n    - dbt source",\n      "type": "object",\n      "properties": {\n        "aws_access_key_id": {\n          "title": "Aws Access Key Id",\n          "description": "Autodetected. See https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html",\n          "type": "string"\n        },\n        "aws_secret_access_key": {\n          "title": "Aws Secret Access Key",\n          "description": "Autodetected. See https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html",\n          "type": "string"\n        },\n        "aws_session_token": {\n          "title": "Aws Session Token",\n          "description": "Autodetected. See https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html",\n          "type": "string"\n        },\n        "aws_role": {\n          "title": "Aws Role",\n          "description": "Autodetected. See https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html",\n          "anyOf": [\n            {\n              "type": "string"\n            },\n            {\n              "type": "array",\n              "items": {\n                "type": "string"\n              }\n            }\n          ]\n        },\n        "aws_profile": {\n          "title": "Aws Profile",\n          "description": "Named AWS profile to use, if not set the default will be used",\n          "type": "string"\n        },\n        "aws_region": {\n          "title": "Aws Region",\n          "description": "AWS region code.",\n          "type": "string"\n        },\n        "aws_endpoint_url": {\n          "title": "Aws Endpoint Url",\n          "description": "Autodetected. See https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html",\n          "type": "string"\n        },\n        "aws_proxy": {\n          "title": "Aws Proxy",\n          "description": "Autodetected. See https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html",\n          "type": "object",\n          "additionalProperties": {\n            "type": "string"\n          }\n        }\n      },\n      "required": [\n        "aws_region"\n      ],\n      "additionalProperties": false\n    },\n    "GitHubInfo": {\n      "title": "GitHubInfo",\n      "type": "object",\n      "properties": {\n        "repo": {\n          "title": "Repo",\n          "description": "Name of your github repo. e.g. repo for https://github.com/datahub-project/datahub is `datahub-project/datahub`.",\n          "type": "string"\n        },\n        "branch": {\n          "title": "Branch",\n          "description": "Branch on which your files live by default. Typically main or master.",\n          "default": "main",\n          "type": "string"\n        },\n        "base_url": {\n          "title": "Base Url",\n          "description": "Base url for Github",\n          "default": "https://github.com",\n          "type": "string"\n        }\n      },\n      "required": [\n        "repo"\n      ],\n      "additionalProperties": false\n    }\n  }\n}\n')))),(0,i.kt)("h3",{id:"dbt-meta-automated-mappings"},"dbt meta automated mappings"),(0,i.kt)("p",null,"dbt allows authors to define meta properties for datasets. Checkout this link to know more - ",(0,i.kt)("a",{parentName:"p",href:"https://docs.getdbt.com/reference/resource-configs/meta"},"dbt meta"),". Our dbt source allows users to define\nactions such as add a tag, term or owner. For example if a dbt model has a meta config ",(0,i.kt)("inlineCode",{parentName:"p"},'"has_pii": True'),", we can define an action\nthat evaluates if the property is set to true and add, lets say, a ",(0,i.kt)("inlineCode",{parentName:"p"},"pii")," tag.\nTo leverage this feature we require users to define mappings as part of the recipe. The following section describes how you can build these mappings. Listed below is a meta_mapping section that among other things, looks for keys like ",(0,i.kt)("inlineCode",{parentName:"p"},"business_owner")," and adds owners that are listed there."),(0,i.kt)(l.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"yaml",label:"YAML",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'meta_mapping:\n  business_owner:\n    match: ".*"\n    operation: "add_owner"\n    config:\n      owner_type: user\n      owner_category: BUSINESS_OWNER\n  has_pii:\n    match: True\n    operation: "add_tag"\n    config:\n      tag: "has_pii_test"\n  int_property:\n    match: 1\n    operation: "add_tag"\n    config:\n      tag: "int_meta_property"\n  double_property:\n    match: 2.5\n    operation: "add_term"\n    config:\n      term: "double_meta_property"\n  data_governance.team_owner:\n    match: "Finance"\n    operation: "add_term"\n    config:\n      term: "Finance_test"\n'))),(0,i.kt)(o.Z,{value:"json",label:"JSON",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'            "meta_mapping": {\n                    "business_owner": {\n                        "match": ".*",\n                        "operation": "add_owner",\n                        "config": {"owner_type": "user", "owner_category": "BUSINESS_OWNER"},\n                    },\n                    "has_pii": {\n                        "match": True,\n                        "operation": "add_tag",\n                        "config": {"tag": "has_pii_test"},\n                    },\n                    "int_property": {\n                        "match": 1,\n                        "operation": "add_tag",\n                        "config": {"tag": "int_meta_property"},\n                    },\n                    "double_property": {\n                        "match": 2.5,\n                        "operation": "add_term",\n                        "config": {"term": "double_meta_property"},\n                    },\n                    "data_governance.team_owner": {\n                        "match": "Finance",\n                        "operation": "add_term",\n                        "config": {"term": "Finance_test"},\n                    },\n                }\n')))),(0,i.kt)("p",null,"We support the following operations:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"add_tag - Requires ",(0,i.kt)("inlineCode",{parentName:"li"},"tag")," property in config."),(0,i.kt)("li",{parentName:"ol"},"add_term - Requires ",(0,i.kt)("inlineCode",{parentName:"li"},"term")," property in config."),(0,i.kt)("li",{parentName:"ol"},"add_owner - Requires ",(0,i.kt)("inlineCode",{parentName:"li"},"owner_type")," property in config which can be either user or group. Optionally accepts the ",(0,i.kt)("inlineCode",{parentName:"li"},"owner_category")," config property which you can set to one of ",(0,i.kt)("inlineCode",{parentName:"li"},"['TECHNICAL_OWNER', 'BUSINESS_OWNER', 'DATA_STEWARD', 'DATAOWNER'")," (defaults to ",(0,i.kt)("inlineCode",{parentName:"li"},"DATAOWNER"),").")),(0,i.kt)("p",null,"Note:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Currently, dbt meta mapping is only supported for meta elements defined at the model level (not supported for columns)."),(0,i.kt)("li",{parentName:"ol"},"For string meta properties we support regex matching.")),(0,i.kt)("p",null,"With regex matching, you can also use the matched value to customize how you populate the tag, term or owner fields. Here are a few advanced examples:"),(0,i.kt)("h4",{id:"data-tier---bronze-silver-gold"},"Data Tier - Bronze, Silver, Gold"),(0,i.kt)("p",null,"If your meta section looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"    meta:\n      data_tier: Bronze # chosen from [Bronze,Gold,Silver]\n")),(0,i.kt)("p",null,"and you wanted to attach a glossary term like ",(0,i.kt)("inlineCode",{parentName:"p"},"urn:li:glossaryTerm:Bronze")," for all the models that have this value in the meta section attached to them, the following meta_mapping section would achieve that outcome:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'meta_mapping:\n  data_tier:\n    match: "Bronze|Silver|Gold"\n    operation: "add_term"\n     config:\n       term: "{{ $match }}"\n')),(0,i.kt)("p",null,"to match any data_tier of Bronze, Silver or Gold and maps it to a glossary term with the same name."),(0,i.kt)("h4",{id:"case-numbers---create-tags"},"Case Numbers - create tags"),(0,i.kt)("p",null,"If your meta section looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"    meta:\n      case: PLT-4678 # internal Case Number\n")),(0,i.kt)("p",null,"and you want to generate tags that look like ",(0,i.kt)("inlineCode",{parentName:"p"},"case_4678")," from this, you can use the following meta_mapping section:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'meta_mapping:\n  case:\n    match: "PLT-(.*)"\n    operation: "add_tag"\n     config:\n       tag: "case_{{ $match }}"\n')),(0,i.kt)("h4",{id:"stripping-out-leading--sign"},"Stripping out leading @ sign"),(0,i.kt)("p",null,"You can also match specific groups within the value to extract subsets of the matched value. e.g. if you have a meta section that looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'meta:\n  owner: "@finance-team"\n  business_owner: "@janet"\n')),(0,i.kt)("p",null,"and you want to mark the finance-team as a group that owns the dataset (skipping the leading @ sign), while marking janet as an individual user (again, skipping the leading @ sign) that owns the dataset, you can use the following meta-mapping section. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'meta_mapping:\n  owner:\n    match: "^@(.*)"\n    operation: "add_owner"\n    config:\n       owner_type: group\n  business_owner:\n    match: "^@(?P<owner>(.*))"\n    operation: "add_owner"\n    config:\n      owner_type: user\n      owner_category: BUSINESS_OWNER\n')),(0,i.kt)("p",null,"In the examples above, we show two ways of writing the matching regexes. In the first one, ",(0,i.kt)("inlineCode",{parentName:"p"},"^@(.*)")," the first matching group (a.k.a. match.group(1)) is automatically inferred. In the second example, ",(0,i.kt)("inlineCode",{parentName:"p"},"^@(?P<owner>(.*))"),", we use a named matching group (called owner, since we are matching an owner) to capture the string we want to provide to the ownership urn."),(0,i.kt)("h3",{id:"dbt-query_tag-automated-mappings"},"dbt query_tag automated mappings"),(0,i.kt)("p",null,"This works similarly as the dbt meta mapping but for the query tags "),(0,i.kt)("p",null,"We support the below actions -"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"add_tag - Requires ",(0,i.kt)("inlineCode",{parentName:"li"},"tag")," property in config.")),(0,i.kt)("p",null,"The below example set as global tag the query tag ",(0,i.kt)("inlineCode",{parentName:"p"},"tag")," key's value. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'"query_tag_mapping":\n{\n   "tag":\n      "match": ".*"\n      "operation": "add_tag"\n      "config":\n        "tag": "{{ $match }}"\n}\n')),(0,i.kt)("h3",{id:"integrating-with-dbt-test"},"Integrating with dbt test"),(0,i.kt)("p",null,"To integrate with dbt tests, the ",(0,i.kt)("inlineCode",{parentName:"p"},"dbt")," source needs access to the ",(0,i.kt)("inlineCode",{parentName:"p"},"run_results.json")," file generated after a ",(0,i.kt)("inlineCode",{parentName:"p"},"dbt test")," execution. Typically, this is written to the ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," directory. A common pattern you can follow is:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Run ",(0,i.kt)("inlineCode",{parentName:"li"},"dbt docs generate")," and upload ",(0,i.kt)("inlineCode",{parentName:"li"},"manifest.json")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"catalog.json")," to a location accessible to the ",(0,i.kt)("inlineCode",{parentName:"li"},"dbt")," source (e.g. s3 or local file system)"),(0,i.kt)("li",{parentName:"ol"},"Run ",(0,i.kt)("inlineCode",{parentName:"li"},"dbt test")," and upload ",(0,i.kt)("inlineCode",{parentName:"li"},"run_results.json")," to a location accessible to the ",(0,i.kt)("inlineCode",{parentName:"li"},"dbt")," source (e.g. s3 or local file system)"),(0,i.kt)("li",{parentName:"ol"},"Run ",(0,i.kt)("inlineCode",{parentName:"li"},"datahub ingest -c dbt_recipe.dhub.yaml")," with the following config parameters specified",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"test_results_path: pointing to the run_results.json file that you just created")))),(0,i.kt)("p",null,"The connector will produce the following things:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Assertion definitions that are attached to the dataset (or datasets)"),(0,i.kt)("li",{parentName:"ul"},"Results from running the tests attached to the timeline of the dataset")),(0,i.kt)("h4",{id:"view-of-dbt-tests-for-a-dataset"},"View of dbt tests for a dataset"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/datahub-project/static-assets/main/imgs/dbt-tests-view.png",alt:"test view"})),(0,i.kt)("h4",{id:"viewing-the-sql-for-a-dbt-test"},"Viewing the SQL for a dbt test"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/datahub-project/static-assets/main/imgs/dbt-test-logic-view.png",alt:"test logic view"})),(0,i.kt)("h4",{id:"viewing-timeline-for-a-failed-dbt-test"},"Viewing timeline for a failed dbt test"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/datahub-project/static-assets/main/imgs/dbt-tests-failure-view.png",alt:"test view"})),(0,i.kt)("h4",{id:"separating-test-result-emission-from-other-metadata-emission"},"Separating test result emission from other metadata emission"),(0,i.kt)("p",null,"You can segregate emission of test results from the emission of other dbt metadata using the ",(0,i.kt)("inlineCode",{parentName:"p"},"entities_enabled")," config flag.\nThe following recipe shows you how to emit only test results."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"source:\n  type: dbt\n  config:\n    manifest_path: _path_to_manifest_json\n    catalog_path: _path_to_catalog_json\n    test_results_path: _path_to_run_results_json\n    target_platform: postgres\n    entities_enabled:\n      test_results: Only\n")),(0,i.kt)("p",null,"Similarly, the following recipe shows you how to emit everything (i.e. models, sources, seeds, test definitions) but not test results:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"source:\n  type: dbt\n  config:\n    manifest_path: _path_to_manifest_json\n    catalog_path: _path_to_catalog_json\n    run_results_path: _path_to_run_results_json\n    target_platform: postgres\n    entities_enabled:\n      test_results: No\n")),(0,i.kt)("h3",{id:"code-coordinates"},"Code Coordinates"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Class Name: ",(0,i.kt)("inlineCode",{parentName:"li"},"datahub.ingestion.source.dbt.DBTSource")),(0,i.kt)("li",{parentName:"ul"},"Browse on ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/src/datahub/ingestion/source/dbt.py"},"GitHub"))),(0,i.kt)("h2",{id:"questions"},"Questions"),(0,i.kt)("p",null,"If you've got any questions on configuring ingestion for dbt, feel free to ping us on ",(0,i.kt)("a",{parentName:"p",href:"https://slack.datahubproject.io"},"our Slack")))}c.isMDXComponent=!0}}]);