"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[7414],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return c}});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),u=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=u(e.components);return i.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},f=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),f=u(n),c=a,m=f["".concat(s,".").concat(c)]||f[c]||p[c]||r;return n?i.createElement(m,l(l({ref:t},d),{},{components:n})):i.createElement(m,l({ref:t},d))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=f;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var u=2;u<r;u++)l[u]=n[u];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}f.displayName="MDXCreateElement"},98448:function(e,t,n){var i=n(67294);t.Z=function(e){var t=e.children,n=e.hidden,a=e.className;return i.createElement("div",{role:"tabpanel",hidden:n,className:a},t)}},37358:function(e,t,n){n.d(t,{Z:function(){return f}});var i=n(87462),a=n(67294),r=n(51048),l=n(22713);var o=function(){var e=(0,a.useContext)(l.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},s=n(12613),u=n(86010),d="tabItem_1uMI";function p(e){var t,n,i,r=e.lazy,l=e.block,p=e.defaultValue,f=e.values,c=e.groupId,m=e.className,g=a.Children.map(e.children,(function(e){if((0,a.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),h=null!=f?f:g.map((function(e){var t=e.props;return{value:t.value,label:t.label}})),b=(0,s.lx)(h,(function(e,t){return e.value===t.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var _=null===p?p:null!=(t=null!=p?p:null==(n=g.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(i=g[0])?void 0:i.props.value;if(null!==_&&!h.some((function(e){return e.value===_})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+_+'" but none of its children has the corresponding value. Available values are: '+h.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var y=o(),v=y.tabGroupChoices,k=y.setTabGroupChoices,w=(0,a.useState)(_),N=w[0],x=w[1],T=[],C=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=c){var P=v[c];null!=P&&P!==N&&h.some((function(e){return e.value===P}))&&x(P)}var S=function(e){var t=e.currentTarget,n=T.indexOf(t),i=h[n].value;i!==N&&(C(t),x(i),null!=c&&k(c,i))},q=function(e){var t,n=null;switch(e.key){case"ArrowRight":var i=T.indexOf(e.currentTarget)+1;n=T[i]||T[0];break;case"ArrowLeft":var a=T.indexOf(e.currentTarget)-1;n=T[a]||T[T.length-1]}null==(t=n)||t.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,u.Z)("tabs",{"tabs--block":l},m)},h.map((function(e){var t=e.value,n=e.label;return a.createElement("li",{role:"tab",tabIndex:N===t?0:-1,"aria-selected":N===t,className:(0,u.Z)("tabs__item",d,{"tabs__item--active":N===t}),key:t,ref:function(e){return T.push(e)},onKeyDown:q,onFocus:S,onClick:S},null!=n?n:t)}))),r?(0,a.cloneElement)(g.filter((function(e){return e.props.value===N}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},g.map((function(e,t){return(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==N})}))))}function f(e){var t=(0,r.Z)();return a.createElement(p,(0,i.Z)({key:String(t)},e))}},22713:function(e,t,n){var i=(0,n(67294).createContext)(void 0);t.Z=i},57433:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return u},contentTitle:function(){return d},metadata:function(){return p},toc:function(){return f},default:function(){return m}});var i=n(87462),a=n(63366),r=(n(67294),n(3905)),l=n(37358),o=n(98448),s=["components"],u={title:"Presto on Hive",slug:"/generated/ingestion/sources/presto-on-hive",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/ingestion/sources/presto-on-hive.md"},d="Presto on Hive",p={unversionedId:"docs/generated/ingestion/sources/presto-on-hive",id:"docs/generated/ingestion/sources/presto-on-hive",isDocsHomePage:!1,title:"Presto on Hive",description:"Module presto-on-hive",source:"@site/genDocs/docs/generated/ingestion/sources/presto-on-hive.md",sourceDirName:"docs/generated/ingestion/sources",slug:"/generated/ingestion/sources/presto-on-hive",permalink:"/docs/generated/ingestion/sources/presto-on-hive",editUrl:"https://github.com/datahub-project/datahub/blob/master/docs/generated/ingestion/sources/presto-on-hive.md",tags:[],version:"current",frontMatter:{title:"Presto on Hive",slug:"/generated/ingestion/sources/presto-on-hive",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/docs/generated/ingestion/sources/presto-on-hive.md"},sidebar:"overviewSidebar",previous:{title:"PowerBI",permalink:"/docs/generated/ingestion/sources/powerbi"},next:{title:"Pulsar",permalink:"/docs/generated/ingestion/sources/pulsar"}},f=[{value:"Module <code>presto-on-hive</code>",id:"module-presto-on-hive",children:[{value:"Important Capabilities",id:"important-capabilities",children:[],level:3},{value:"Install the Plugin",id:"install-the-plugin",children:[],level:3},{value:"Quickstart Recipe",id:"quickstart-recipe",children:[],level:3},{value:"Config Details",id:"config-details",children:[],level:3},{value:"Code Coordinates",id:"code-coordinates",children:[],level:3}],level:2},{value:"Questions",id:"questions",children:[],level:2}],c={toc:f};function m(e){var t=e.components,n=(0,a.Z)(e,s);return(0,r.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"presto-on-hive"},"Presto on Hive"),(0,r.kt)("h2",{id:"module-presto-on-hive"},"Module ",(0,r.kt)("inlineCode",{parentName:"h2"},"presto-on-hive")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://img.shields.io/badge/support%20status-certified-brightgreen",alt:"Certified"})),(0,r.kt)("h3",{id:"important-capabilities"},"Important Capabilities"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Capability"),(0,r.kt)("th",{parentName:"tr",align:null},"Status"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/metadata-ingestion/docs/dev_guides/sql_profiles"},"Data Profiling")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"Optionally enabled via configuration")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/metadata-ingestion/docs/dev_guides/stateful#removal-of-stale-tables-and-views"},"Detect Deleted Entities")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"Enabled via stateful ingestion")))),(0,r.kt)("p",null,"This plugin extracts the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Metadata for Presto views and Hive tables (external / managed)"),(0,r.kt)("li",{parentName:"ul"},"Column types associated with each table / view"),(0,r.kt)("li",{parentName:"ul"},"Detailed table / view property info")),(0,r.kt)("h3",{id:"install-the-plugin"},"Install the Plugin"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"pip install 'acryl-datahub[presto-on-hive]'\n")),(0,r.kt)("h3",{id:"quickstart-recipe"},"Quickstart Recipe"),(0,r.kt)("p",null,"Check out the following recipe to get started with ingestion! See ",(0,r.kt)("a",{parentName:"p",href:"#config-details"},"below")," for full configuration options."),(0,r.kt)("p",null,"For general pointers on writing and running a recipe, see our ",(0,r.kt)("a",{parentName:"p",href:"/docs/metadata-ingestion#recipes"},"main recipe guide")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"source:\n  type: presto-on-hive\n  config:\n    # Hive metastore DB connection\n    host_port: localhost:5432\n    database: metastore\n\n    # specify the schema where metastore tables reside\n    schema_pattern:\n      allow:\n        - \"^public\"\n\n    # credentials\n    username: user # optional\n    password: pass # optional\n\n    #scheme: 'postgresql+psycopg2' # set this if metastore db is using postgres\n    #scheme: 'mysql+pymysql' # set this if metastore db is using mysql, default if unset\n\n    # set this to have advanced filters on what to ingest\n    #views_where_clause_suffix: AND d.\"name\" in ('db1')\n    #tables_where_clause_suffix: AND d.\"name\" in ('db1')\n\nsink:\n  # sink configs\n")),(0,r.kt)("h3",{id:"config-details"},"Config Details"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"options",label:"Options",default:!0,mdxType:"TabItem"},(0,r.kt)("p",null,"Note that a ",(0,r.kt)("inlineCode",{parentName:"p"},".")," is used to denote nested fields in the YAML recipe."),(0,r.kt)("details",{open:!0},(0,r.kt)("summary",null,"View All Configuration Options"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"env"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The environment that all assets produced by this connector belong to"),(0,r.kt)("td",{parentName:"tr",align:null},"PROD")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"platform"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The platform that this source connects to"),(0,r.kt)("td",{parentName:"tr",align:null},"None")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"platform_instance"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The instance of the platform that all assets produced by this recipe belong to"),(0,r.kt)("td",{parentName:"tr",align:null},"None")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"options"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"Dict"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"{}")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"include_views"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},"Whether views should be ingested."),(0,r.kt)("td",{parentName:"tr",align:null},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"include_tables"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},"Whether tables should be ingested."),(0,r.kt)("td",{parentName:"tr",align:null},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"username"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"username"),(0,r.kt)("td",{parentName:"tr",align:null},"None")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"password"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"password"),(0,r.kt)("td",{parentName:"tr",align:null},"None")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"host_port"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Host URL and port to connect to. Example: localhost:3306"),(0,r.kt)("td",{parentName:"tr",align:null},"localhost:3306")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"database"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"database (catalog)"),(0,r.kt)("td",{parentName:"tr",align:null},"None")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"database_alias"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Alias to apply to database when ingesting."),(0,r.kt)("td",{parentName:"tr",align:null},"None")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"scheme"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"mysql+pymysql")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sqlalchemy_uri"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"URI of database to connect to. See ",(0,r.kt)("a",{parentName:"td",href:"https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls"},"https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls"),". Takes precedence over other connection parameters."),(0,r.kt)("td",{parentName:"tr",align:null},"None")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"views_where_clause_suffix"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Where clause to specify what Presto views should be ingested."),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tables_where_clause_suffix"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Where clause to specify what Hive tables should be ingested."),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"schemas_where_clause_suffix"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Where clause to specify what Hive schemas should be ingested."),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"metastore_db_name"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"Name of the Hive metastore's database (usually: metastore)."),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    For backwardcompatibility, if this field is not provided, the 'database' field will be used.\n    If both the 'database' and 'metastore_db_name' fields are set then the 'database'\n    field will be used to filter the hive/presto/trino database | None |\n")),(0,r.kt)("p",null,"| mode |  | enum(PrestoOnHiveConfigMode) | The ingested data will be stored under this platform.\nValid options: ","['hive', 'presto', 'presto-on-hive', 'trino']"," | presto-on-hive |\n| stateful_ingestion |  | SQLAlchemyStatefulIngestionConfig (see below for fields) |  |  |\n| stateful_ingestion.enabled |  | boolean | The type of the ingestion state provider registered with datahub. | False |\n| stateful_ingestion.max_checkpoint_state_size |  | integer | The maximum size of the checkpoint state in bytes. Default is 16MB | 16777216 |\n| stateful_ingestion.state_provider |  | DynamicTypedStateProviderConfig (see below for fields) | The ingestion state provider configuration. |  |\n| stateful_ingestion.state_provider.type | \u2705 | string | The type of the state provider to use. For DataHub use ",(0,r.kt)("inlineCode",{parentName:"p"},"datahub")," | None |\n| stateful_ingestion.state_provider.config |  | Generic dict | The configuration required for initializing the state provider. Default: The datahub_api config if set at pipeline level. Otherwise, the default DatahubClientConfig. See the defaults (",(0,r.kt)("a",{parentName:"p",href:"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/src/datahub/ingestion/graph/client.py#L19"},"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/src/datahub/ingestion/graph/client.py#L19"),"). | None |\n| stateful_ingestion.ignore_old_state |  | boolean | If set to True, ignores the previous checkpoint state. | False |\n| stateful_ingestion.ignore_new_state |  | boolean | If set to True, ignores the current checkpoint state. | False |\n| stateful_ingestion.remove_stale_metadata |  | boolean | Soft-deletes the tables and views that were found in the last successful run but missing in the current run with stateful_ingestion enabled. | True |\n| schema_pattern |  | AllowDenyPattern (see below for fields) | Regex patterns for schemas to filter in ingestion. Specify regex to only match the schema name. e.g. to match all tables in schema analytics, use the regex 'analytics' | {'allow': ","['.*']",", 'deny': [], 'ignoreCase': True} |\n| schema_pattern.allow |  | Array of string | List of regex patterns to include in ingestion | ","['.*']"," |\n| schema_pattern.deny |  | Array of string | List of regex patterns to exclude from ingestion. | [] |\n| schema_pattern.ignoreCase |  | boolean | Whether to ignore case sensitivity during pattern matching. | True |\n| table_pattern |  | AllowDenyPattern (see below for fields) | Regex patterns for tables to filter in ingestion. Specify regex to match the entire table name in database.schema.table format. e.g. to match all tables starting with customer in Customer database and public schema, use the regex 'Customer.public.customer.",(0,r.kt)("em",{parentName:"p"},"' | {'allow': ['."),"'], 'deny': [], 'ignoreCase': True} |\n| table_pattern.allow |  | Array of string | List of regex patterns to include in ingestion | ","['.*']"," |\n| table_pattern.deny |  | Array of string | List of regex patterns to exclude from ingestion. | [] |\n| table_pattern.ignoreCase |  | boolean | Whether to ignore case sensitivity during pattern matching. | True |\n| view_pattern |  | AllowDenyPattern (see below for fields) | Regex patterns for views to filter in ingestion. Note: Defaults to table_pattern if not specified. Specify regex to match the entire view name in database.schema.view format. e.g. to match all views starting with customer in Customer database and public schema, use the regex 'Customer.public.customer.",(0,r.kt)("em",{parentName:"p"},"' | {'allow': ['."),"'], 'deny': [], 'ignoreCase': True} |\n| view_pattern.allow |  | Array of string | List of regex patterns to include in ingestion | ","['.*']"," |\n| view_pattern.deny |  | Array of string | List of regex patterns to exclude from ingestion. | [] |\n| view_pattern.ignoreCase |  | boolean | Whether to ignore case sensitivity during pattern matching. | True |\n| profile_pattern |  | AllowDenyPattern (see below for fields) | Regex patterns to filter tables for profiling during ingestion. Allowed by the ",(0,r.kt)("inlineCode",{parentName:"p"},"table_pattern"),". | {'allow': ","['.*']",", 'deny': [], 'ignoreCase': True} |\n| profile_pattern.allow |  | Array of string | List of regex patterns to include in ingestion | ","['.*']"," |\n| profile_pattern.deny |  | Array of string | List of regex patterns to exclude from ingestion. | [] |\n| profile_pattern.ignoreCase |  | boolean | Whether to ignore case sensitivity during pattern matching. | True |\n| domain |  | Dict","[str, AllowDenyPattern]"," | Attach domains to databases, schemas or tables during ingestion using regex patterns. Domain key can be a guid like ",(0,r.kt)("em",{parentName:"p"},"urn:li:domain:ec428203-ce86-4db3-985d-5a8ee6df32ba"),' or a string like "Marketing".) If you provide strings, then datahub will attempt to resolve this name to a guid, and will error out if this fails. There can be multiple domain keys specified. | {} |\n| domain.',(0,r.kt)("inlineCode",{parentName:"p"},"key"),".allow |  | Array of string | List of regex patterns to include in ingestion | ","['.*']"," |\n| domain.",(0,r.kt)("inlineCode",{parentName:"p"},"key"),".deny |  | Array of string | List of regex patterns to exclude from ingestion. | [] |\n| domain.",(0,r.kt)("inlineCode",{parentName:"p"},"key"),".ignoreCase |  | boolean | Whether to ignore case sensitivity during pattern matching. | True |\n| profiling |  | GEProfilingConfig (see below for fields) |  | {'enabled': False, 'limit': None, 'offset': None, 'report_dropped_profiles': False, 'turn_off_expensive_profiling_metrics': False, 'profile_table_level_only': False, 'include_field_null_count': True, 'include_field_min_value': True, 'include_field_max_value': True, 'include_field_mean_value': True, 'include_field_median_value': True, 'include_field_stddev_value': True, 'include_field_quantiles': False, 'include_field_distinct_value_frequencies': False, 'include_field_histogram': False, 'include_field_sample_values': True, 'allow_deny_patterns': {'allow': ","['.*']",", 'deny': [], 'ignoreCase': True}, 'max_number_of_fields_to_profile': None, 'profile_if_updated_since_days': 1, 'profile_table_size_limit': 1, 'profile_table_row_limit': 50000, 'max_workers': 10, 'query_combiner_enabled': True, 'catch_exceptions': True, 'partition_profiling_enabled': True, 'bigquery_temp_table_schema': None, 'partition_datetime': None} |\n| profiling.enabled |  | boolean | Whether profiling should be done. | False |\n| profiling.limit |  | integer | Max number of documents to profile. By default, profiles all documents. | None |\n| profiling.offset |  | integer | Offset in documents to profile. By default, uses no offset. | None |\n| profiling.report_dropped_profiles |  | boolean | If datasets which were not profiled are reported in source report or not. Set to ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," for debugging purposes. | False |\n| profiling.turn_off_expensive_profiling_metrics |  | boolean | Whether to turn off expensive profiling or not. This turns off profiling for quantiles, distinct_value_frequencies, histogram & sample_values. This also limits maximum number of fields being profiled to 10. | False |\n| profiling.profile_table_level_only |  | boolean | Whether to perform profiling at table-level only, or include column-level profiling as well. | False |\n| profiling.include_field_null_count |  | boolean | Whether to profile for the number of nulls for each column. | True |\n| profiling.include_field_min_value |  | boolean | Whether to profile for the min value of numeric columns. | True |\n| profiling.include_field_max_value |  | boolean | Whether to profile for the max value of numeric columns. | True |\n| profiling.include_field_mean_value |  | boolean | Whether to profile for the mean value of numeric columns. | True |\n| profiling.include_field_median_value |  | boolean | Whether to profile for the median value of numeric columns. | True |\n| profiling.include_field_stddev_value |  | boolean | Whether to profile for the standard deviation of numeric columns. | True |\n| profiling.include_field_quantiles |  | boolean | Whether to profile for the quantiles of numeric columns. | False |\n| profiling.include_field_distinct_value_frequencies |  | boolean | Whether to profile for distinct value frequencies. | False |\n| profiling.include_field_histogram |  | boolean | Whether to profile for the histogram for numeric fields. | False |\n| profiling.include_field_sample_values |  | boolean | Whether to profile for the sample values for all columns. | True |\n| profiling.allow_deny_patterns |  | AllowDenyPattern (see below for fields) | regex patterns for filtering of tables or table columns to profile. | {'allow': ","['.*']",", 'deny': [], 'ignoreCase': True} |\n| profiling.allow_deny_patterns.allow |  | Array of string | List of regex patterns to include in ingestion | ","['.*']"," |\n| profiling.allow_deny_patterns.deny |  | Array of string | List of regex patterns to exclude from ingestion. | [] |\n| profiling.allow_deny_patterns.ignoreCase |  | boolean | Whether to ignore case sensitivity during pattern matching. | True |\n| profiling.max_number_of_fields_to_profile |  | integer | A positive integer that specifies the maximum number of columns to profile for any table. ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," implies all columns. The cost of profiling goes up significantly as the number of columns to profile goes up. | None |\n| profiling.profile_if_updated_since_days |  | number | Profile table only if it has been updated since these many number of days. If set to ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", no constraint of last modified time for tables to profile. Supported only in ",(0,r.kt)("inlineCode",{parentName:"p"},"snowflake"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"snowflake-beta")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BigQuery"),". | 1 |\n| profiling.profile_table_size_limit |  | integer | Profile tables only if their size is less then specified GBs. If set to ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", no limit on the size of tables to profile. Supported only in ",(0,r.kt)("inlineCode",{parentName:"p"},"snowflake-beta")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BigQuery")," | 1 |\n| profiling.profile_table_row_limit |  | integer | Profile tables only if their row count is less then specified count. If set to ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", no limit on the row count of tables to profile. Supported only in ",(0,r.kt)("inlineCode",{parentName:"p"},"snowflake-beta")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"BigQuery")," | 50000 |\n| profiling.max_workers |  | integer | Number of worker threads to use for profiling. Set to 1 to disable. | 10 |\n| profiling.query_combiner_enabled |  | boolean | ",(0,r.kt)("em",{parentName:"p"},"This feature is still experimental and can be disabled if it causes issues.")," Reduces the total number of queries issued and speeds up profiling by dynamically combining SQL queries where possible. | True |\n| profiling.catch_exceptions |  | boolean |  | True |\n| profiling.partition_profiling_enabled |  | boolean |  | True |\n| profiling.bigquery_temp_table_schema |  | string | On bigquery for profiling partitioned tables needs to create temporary views. You have to define a dataset where these will be created. Views will be cleaned up after profiler runs. (Great expectation tech details about this (",(0,r.kt)("a",{parentName:"p",href:"https://legacy.docs.greatexpectations.io/en/0.9.0/reference/integrations/bigquery.html#custom-queries-with-sql-datasource"},"https://legacy.docs.greatexpectations.io/en/0.9.0/reference/integrations/bigquery.html#custom-queries-with-sql-datasource"),"). | None |\n| profiling.partition_datetime |  | string | For partitioned datasets profile only the partition which matches the datetime or profile the latest one if not set. Only Bigquery supports this. | None |"))),(0,r.kt)(o.Z,{value:"schema",label:"Schema",mdxType:"TabItem"},(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://json-schema.org/"},"JSONSchema")," for this configuration is inlined below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "title": "PrestoOnHiveConfig",\n  "description": "Base configuration class for stateful ingestion for source configs to inherit from.",\n  "type": "object",\n  "properties": {\n    "env": {\n      "title": "Env",\n      "description": "The environment that all assets produced by this connector belong to",\n      "default": "PROD",\n      "type": "string"\n    },\n    "platform": {\n      "title": "Platform",\n      "description": "The platform that this source connects to",\n      "type": "string"\n    },\n    "platform_instance": {\n      "title": "Platform Instance",\n      "description": "The instance of the platform that all assets produced by this recipe belong to",\n      "type": "string"\n    },\n    "stateful_ingestion": {\n      "$ref": "#/definitions/SQLAlchemyStatefulIngestionConfig"\n    },\n    "options": {\n      "title": "Options",\n      "default": {},\n      "type": "object"\n    },\n    "schema_pattern": {\n      "title": "Schema Pattern",\n      "description": "Regex patterns for schemas to filter in ingestion. Specify regex to only match the schema name. e.g. to match all tables in schema analytics, use the regex \'analytics\'",\n      "default": {\n        "allow": [\n          ".*"\n        ],\n        "deny": [],\n        "ignoreCase": true\n      },\n      "allOf": [\n        {\n          "$ref": "#/definitions/AllowDenyPattern"\n        }\n      ]\n    },\n    "table_pattern": {\n      "title": "Table Pattern",\n      "description": "Regex patterns for tables to filter in ingestion. Specify regex to match the entire table name in database.schema.table format. e.g. to match all tables starting with customer in Customer database and public schema, use the regex \'Customer.public.customer.*\'",\n      "default": {\n        "allow": [\n          ".*"\n        ],\n        "deny": [],\n        "ignoreCase": true\n      },\n      "allOf": [\n        {\n          "$ref": "#/definitions/AllowDenyPattern"\n        }\n      ]\n    },\n    "view_pattern": {\n      "title": "View Pattern",\n      "description": "Regex patterns for views to filter in ingestion. Note: Defaults to table_pattern if not specified. Specify regex to match the entire view name in database.schema.view format. e.g. to match all views starting with customer in Customer database and public schema, use the regex \'Customer.public.customer.*\'",\n      "default": {\n        "allow": [\n          ".*"\n        ],\n        "deny": [],\n        "ignoreCase": true\n      },\n      "allOf": [\n        {\n          "$ref": "#/definitions/AllowDenyPattern"\n        }\n      ]\n    },\n    "profile_pattern": {\n      "title": "Profile Pattern",\n      "description": "Regex patterns to filter tables for profiling during ingestion. Allowed by the `table_pattern`.",\n      "default": {\n        "allow": [\n          ".*"\n        ],\n        "deny": [],\n        "ignoreCase": true\n      },\n      "allOf": [\n        {\n          "$ref": "#/definitions/AllowDenyPattern"\n        }\n      ]\n    },\n    "domain": {\n      "title": "Domain",\n      "description": "Attach domains to databases, schemas or tables during ingestion using regex patterns. Domain key can be a guid like *urn:li:domain:ec428203-ce86-4db3-985d-5a8ee6df32ba* or a string like \\"Marketing\\".) If you provide strings, then datahub will attempt to resolve this name to a guid, and will error out if this fails. There can be multiple domain keys specified.",\n      "default": {},\n      "type": "object",\n      "additionalProperties": {\n        "$ref": "#/definitions/AllowDenyPattern"\n      }\n    },\n    "include_views": {\n      "title": "Include Views",\n      "description": "Whether views should be ingested.",\n      "default": true,\n      "type": "boolean"\n    },\n    "include_tables": {\n      "title": "Include Tables",\n      "description": "Whether tables should be ingested.",\n      "default": true,\n      "type": "boolean"\n    },\n    "profiling": {\n      "title": "Profiling",\n      "default": {\n        "enabled": false,\n        "limit": null,\n        "offset": null,\n        "report_dropped_profiles": false,\n        "turn_off_expensive_profiling_metrics": false,\n        "profile_table_level_only": false,\n        "include_field_null_count": true,\n        "include_field_min_value": true,\n        "include_field_max_value": true,\n        "include_field_mean_value": true,\n        "include_field_median_value": true,\n        "include_field_stddev_value": true,\n        "include_field_quantiles": false,\n        "include_field_distinct_value_frequencies": false,\n        "include_field_histogram": false,\n        "include_field_sample_values": true,\n        "allow_deny_patterns": {\n          "allow": [\n            ".*"\n          ],\n          "deny": [],\n          "ignoreCase": true\n        },\n        "max_number_of_fields_to_profile": null,\n        "profile_if_updated_since_days": 1,\n        "profile_table_size_limit": 1,\n        "profile_table_row_limit": 50000,\n        "max_workers": 10,\n        "query_combiner_enabled": true,\n        "catch_exceptions": true,\n        "partition_profiling_enabled": true,\n        "bigquery_temp_table_schema": null,\n        "partition_datetime": null\n      },\n      "allOf": [\n        {\n          "$ref": "#/definitions/GEProfilingConfig"\n        }\n      ]\n    },\n    "username": {\n      "title": "Username",\n      "description": "username",\n      "type": "string"\n    },\n    "password": {\n      "title": "Password",\n      "description": "password",\n      "type": "string",\n      "writeOnly": true,\n      "format": "password"\n    },\n    "host_port": {\n      "title": "Host Port",\n      "description": "Host URL and port to connect to. Example: localhost:3306",\n      "default": "localhost:3306",\n      "type": "string"\n    },\n    "database": {\n      "title": "Database",\n      "description": "database (catalog)",\n      "type": "string"\n    },\n    "database_alias": {\n      "title": "Database Alias",\n      "description": "Alias to apply to database when ingesting.",\n      "type": "string"\n    },\n    "scheme": {\n      "title": "Scheme",\n      "default": "mysql+pymysql",\n      "type": "string"\n    },\n    "sqlalchemy_uri": {\n      "title": "Sqlalchemy Uri",\n      "description": "URI of database to connect to. See https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls. Takes precedence over other connection parameters.",\n      "type": "string"\n    },\n    "views_where_clause_suffix": {\n      "title": "Views Where Clause Suffix",\n      "description": "Where clause to specify what Presto views should be ingested.",\n      "default": "",\n      "type": "string"\n    },\n    "tables_where_clause_suffix": {\n      "title": "Tables Where Clause Suffix",\n      "description": "Where clause to specify what Hive tables should be ingested.",\n      "default": "",\n      "type": "string"\n    },\n    "schemas_where_clause_suffix": {\n      "title": "Schemas Where Clause Suffix",\n      "description": "Where clause to specify what Hive schemas should be ingested.",\n      "default": "",\n      "type": "string"\n    },\n    "metastore_db_name": {\n      "title": "Metastore Db Name",\n      "description": "Name of the Hive metastore\'s database (usually: metastore).\\n        For backwardcompatibility, if this field is not provided, the \'database\' field will be used.\\n        If both the \'database\' and \'metastore_db_name\' fields are set then the \'database\'\\n        field will be used to filter the hive/presto/trino database",\n      "type": "string"\n    },\n    "mode": {\n      "description": "The ingested data will be stored under this platform.\\n        Valid options: [\'hive\', \'presto\', \'presto-on-hive\', \'trino\']",\n      "default": "presto-on-hive",\n      "allOf": [\n        {\n          "$ref": "#/definitions/PrestoOnHiveConfigMode"\n        }\n      ]\n    }\n  },\n  "additionalProperties": false,\n  "definitions": {\n    "DynamicTypedStateProviderConfig": {\n      "title": "DynamicTypedStateProviderConfig",\n      "type": "object",\n      "properties": {\n        "type": {\n          "title": "Type",\n          "description": "The type of the state provider to use. For DataHub use `datahub`",\n          "type": "string"\n        },\n        "config": {\n          "title": "Config",\n          "description": "The configuration required for initializing the state provider. Default: The datahub_api config if set at pipeline level. Otherwise, the default DatahubClientConfig. See the defaults (https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/src/datahub/ingestion/graph/client.py#L19)."\n        }\n      },\n      "required": [\n        "type"\n      ],\n      "additionalProperties": false\n    },\n    "SQLAlchemyStatefulIngestionConfig": {\n      "title": "SQLAlchemyStatefulIngestionConfig",\n      "description": "Specialization of basic StatefulIngestionConfig to adding custom config.\\nThis will be used to override the stateful_ingestion config param of StatefulIngestionConfigBase\\nin the SQLAlchemyConfig.",\n      "type": "object",\n      "properties": {\n        "enabled": {\n          "title": "Enabled",\n          "description": "The type of the ingestion state provider registered with datahub.",\n          "default": false,\n          "type": "boolean"\n        },\n        "max_checkpoint_state_size": {\n          "title": "Max Checkpoint State Size",\n          "description": "The maximum size of the checkpoint state in bytes. Default is 16MB",\n          "default": 16777216,\n          "exclusiveMinimum": 0,\n          "type": "integer"\n        },\n        "state_provider": {\n          "title": "State Provider",\n          "description": "The ingestion state provider configuration.",\n          "allOf": [\n            {\n              "$ref": "#/definitions/DynamicTypedStateProviderConfig"\n            }\n          ]\n        },\n        "ignore_old_state": {\n          "title": "Ignore Old State",\n          "description": "If set to True, ignores the previous checkpoint state.",\n          "default": false,\n          "type": "boolean"\n        },\n        "ignore_new_state": {\n          "title": "Ignore New State",\n          "description": "If set to True, ignores the current checkpoint state.",\n          "default": false,\n          "type": "boolean"\n        },\n        "remove_stale_metadata": {\n          "title": "Remove Stale Metadata",\n          "description": "Soft-deletes the tables and views that were found in the last successful run but missing in the current run with stateful_ingestion enabled.",\n          "default": true,\n          "type": "boolean"\n        }\n      },\n      "additionalProperties": false\n    },\n    "AllowDenyPattern": {\n      "title": "AllowDenyPattern",\n      "description": "A class to store allow deny regexes",\n      "type": "object",\n      "properties": {\n        "allow": {\n          "title": "Allow",\n          "description": "List of regex patterns to include in ingestion",\n          "default": [\n            ".*"\n          ],\n          "type": "array",\n          "items": {\n            "type": "string"\n          }\n        },\n        "deny": {\n          "title": "Deny",\n          "description": "List of regex patterns to exclude from ingestion.",\n          "default": [],\n          "type": "array",\n          "items": {\n            "type": "string"\n          }\n        },\n        "ignoreCase": {\n          "title": "Ignorecase",\n          "description": "Whether to ignore case sensitivity during pattern matching.",\n          "default": true,\n          "type": "boolean"\n        }\n      },\n      "additionalProperties": false\n    },\n    "GEProfilingConfig": {\n      "title": "GEProfilingConfig",\n      "type": "object",\n      "properties": {\n        "enabled": {\n          "title": "Enabled",\n          "description": "Whether profiling should be done.",\n          "default": false,\n          "type": "boolean"\n        },\n        "limit": {\n          "title": "Limit",\n          "description": "Max number of documents to profile. By default, profiles all documents.",\n          "type": "integer"\n        },\n        "offset": {\n          "title": "Offset",\n          "description": "Offset in documents to profile. By default, uses no offset.",\n          "type": "integer"\n        },\n        "report_dropped_profiles": {\n          "title": "Report Dropped Profiles",\n          "description": "If datasets which were not profiled are reported in source report or not. Set to `True` for debugging purposes.",\n          "default": false,\n          "type": "boolean"\n        },\n        "turn_off_expensive_profiling_metrics": {\n          "title": "Turn Off Expensive Profiling Metrics",\n          "description": "Whether to turn off expensive profiling or not. This turns off profiling for quantiles, distinct_value_frequencies, histogram & sample_values. This also limits maximum number of fields being profiled to 10.",\n          "default": false,\n          "type": "boolean"\n        },\n        "profile_table_level_only": {\n          "title": "Profile Table Level Only",\n          "description": "Whether to perform profiling at table-level only, or include column-level profiling as well.",\n          "default": false,\n          "type": "boolean"\n        },\n        "include_field_null_count": {\n          "title": "Include Field Null Count",\n          "description": "Whether to profile for the number of nulls for each column.",\n          "default": true,\n          "type": "boolean"\n        },\n        "include_field_min_value": {\n          "title": "Include Field Min Value",\n          "description": "Whether to profile for the min value of numeric columns.",\n          "default": true,\n          "type": "boolean"\n        },\n        "include_field_max_value": {\n          "title": "Include Field Max Value",\n          "description": "Whether to profile for the max value of numeric columns.",\n          "default": true,\n          "type": "boolean"\n        },\n        "include_field_mean_value": {\n          "title": "Include Field Mean Value",\n          "description": "Whether to profile for the mean value of numeric columns.",\n          "default": true,\n          "type": "boolean"\n        },\n        "include_field_median_value": {\n          "title": "Include Field Median Value",\n          "description": "Whether to profile for the median value of numeric columns.",\n          "default": true,\n          "type": "boolean"\n        },\n        "include_field_stddev_value": {\n          "title": "Include Field Stddev Value",\n          "description": "Whether to profile for the standard deviation of numeric columns.",\n          "default": true,\n          "type": "boolean"\n        },\n        "include_field_quantiles": {\n          "title": "Include Field Quantiles",\n          "description": "Whether to profile for the quantiles of numeric columns.",\n          "default": false,\n          "type": "boolean"\n        },\n        "include_field_distinct_value_frequencies": {\n          "title": "Include Field Distinct Value Frequencies",\n          "description": "Whether to profile for distinct value frequencies.",\n          "default": false,\n          "type": "boolean"\n        },\n        "include_field_histogram": {\n          "title": "Include Field Histogram",\n          "description": "Whether to profile for the histogram for numeric fields.",\n          "default": false,\n          "type": "boolean"\n        },\n        "include_field_sample_values": {\n          "title": "Include Field Sample Values",\n          "description": "Whether to profile for the sample values for all columns.",\n          "default": true,\n          "type": "boolean"\n        },\n        "allow_deny_patterns": {\n          "title": "Allow Deny Patterns",\n          "description": "regex patterns for filtering of tables or table columns to profile.",\n          "default": {\n            "allow": [\n              ".*"\n            ],\n            "deny": [],\n            "ignoreCase": true\n          },\n          "allOf": [\n            {\n              "$ref": "#/definitions/AllowDenyPattern"\n            }\n          ]\n        },\n        "max_number_of_fields_to_profile": {\n          "title": "Max Number Of Fields To Profile",\n          "description": "A positive integer that specifies the maximum number of columns to profile for any table. `None` implies all columns. The cost of profiling goes up significantly as the number of columns to profile goes up.",\n          "exclusiveMinimum": 0,\n          "type": "integer"\n        },\n        "profile_if_updated_since_days": {\n          "title": "Profile If Updated Since Days",\n          "description": "Profile table only if it has been updated since these many number of days. If set to `null`, no constraint of last modified time for tables to profile. Supported only in `snowflake`, `snowflake-beta` and `BigQuery`.",\n          "default": 1,\n          "exclusiveMinimum": 0,\n          "type": "number"\n        },\n        "profile_table_size_limit": {\n          "title": "Profile Table Size Limit",\n          "description": "Profile tables only if their size is less then specified GBs. If set to `null`, no limit on the size of tables to profile. Supported only in `snowflake-beta` and `BigQuery`",\n          "default": 1,\n          "type": "integer"\n        },\n        "profile_table_row_limit": {\n          "title": "Profile Table Row Limit",\n          "description": "Profile tables only if their row count is less then specified count. If set to `null`, no limit on the row count of tables to profile. Supported only in `snowflake-beta` and `BigQuery`",\n          "default": 50000,\n          "type": "integer"\n        },\n        "max_workers": {\n          "title": "Max Workers",\n          "description": "Number of worker threads to use for profiling. Set to 1 to disable.",\n          "default": 10,\n          "type": "integer"\n        },\n        "query_combiner_enabled": {\n          "title": "Query Combiner Enabled",\n          "description": "*This feature is still experimental and can be disabled if it causes issues.* Reduces the total number of queries issued and speeds up profiling by dynamically combining SQL queries where possible.",\n          "default": true,\n          "type": "boolean"\n        },\n        "catch_exceptions": {\n          "title": "Catch Exceptions",\n          "default": true,\n          "type": "boolean"\n        },\n        "partition_profiling_enabled": {\n          "title": "Partition Profiling Enabled",\n          "default": true,\n          "type": "boolean"\n        },\n        "bigquery_temp_table_schema": {\n          "title": "Bigquery Temp Table Schema",\n          "description": "On bigquery for profiling partitioned tables needs to create temporary views. You have to define a dataset where these will be created. Views will be cleaned up after profiler runs. (Great expectation tech details about this (https://legacy.docs.greatexpectations.io/en/0.9.0/reference/integrations/bigquery.html#custom-queries-with-sql-datasource).",\n          "type": "string"\n        },\n        "partition_datetime": {\n          "title": "Partition Datetime",\n          "description": "For partitioned datasets profile only the partition which matches the datetime or profile the latest one if not set. Only Bigquery supports this.",\n          "type": "string",\n          "format": "date-time"\n        }\n      },\n      "additionalProperties": false\n    },\n    "PrestoOnHiveConfigMode": {\n      "title": "PrestoOnHiveConfigMode",\n      "description": "An enumeration.",\n      "enum": [\n        "hive",\n        "presto",\n        "presto-on-hive",\n        "trino"\n      ],\n      "type": "string"\n    }\n  }\n}\n')))),(0,r.kt)("h3",{id:"code-coordinates"},"Code Coordinates"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Class Name: ",(0,r.kt)("inlineCode",{parentName:"li"},"datahub.ingestion.source.sql.presto_on_hive.PrestoOnHiveSource")),(0,r.kt)("li",{parentName:"ul"},"Browse on ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/src/datahub/ingestion/source/sql/presto_on_hive.py"},"GitHub"))),(0,r.kt)("h2",{id:"questions"},"Questions"),(0,r.kt)("p",null,"If you've got any questions on configuring ingestion for Presto on Hive, feel free to ping us on ",(0,r.kt)("a",{parentName:"p",href:"https://slack.datahubproject.io"},"our Slack")))}m.isMDXComponent=!0}}]);